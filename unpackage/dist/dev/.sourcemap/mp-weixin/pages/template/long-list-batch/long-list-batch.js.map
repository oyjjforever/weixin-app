{"version":3,"file":"long-list-batch.js","sources":["pages/template/long-list-batch/long-list-batch.uvue","../../../Program Files/HBuilderX/plugins/uniapp-cli-vite/uniPage:/cGFnZXNcdGVtcGxhdGVcbG9uZy1saXN0LWJhdGNoXGxvbmctbGlzdC1iYXRjaC51dnVl"],"sourcesContent":["<template>\r\n  <view style=\"flex: 1; background-color: aliceblue\">\r\n    <view class=\"tips\">list-view组件虽然在渲染层有recycle机制，但长列表的vnode/Element太多也会造成初始化卡顿。\r\n    本示例有2000条数据，通过分批创建列表项，减少初始化卡顿。并通过闲时创建机制避免影响列表滚动等UI操作</view>\r\n    <list-view style=\"flex: 1\" :refresher-enabled=\"true\" :refresher-triggered=\"refresherTriggered\" @scroll=\"onScroll\"\r\n      @scrolltolower=\"onScrollToLower\" @refresherrefresh=\"onRefresh\" @refresherpulling=\"onRefresherPulling\" @refresherrestore=\"onRefresherRestore\">\r\n      <list-item class=\"item\" v-for=\"(item, index) in list\" :key=\"index + '_' + item.id\">\r\n        <view><text>{{ item.name }}</text></view>\r\n        <view><text style=\"font-size: 12px; color: #999999\">{{\r\n            item.info\r\n          }}</text></view>\r\n      </list-item>\r\n    </list-view>\r\n  </view>\r\n</template>\r\n\r\n<script setup lang=\"uts\">\r\n  type Item = {\r\n    id : number;\r\n    name : string;\r\n    info : string;\r\n  };\r\n\r\n  class Jobs {\r\n    private jobs : (() => Promise<void>)[] = [];\r\n    paused : boolean = true;\r\n    constructor() { }\r\n    add(job : () => Promise<void>) {\r\n      this.jobs.push(job);\r\n    }\r\n    pause() {\r\n      this.paused = true;\r\n    }\r\n    private execute() {\r\n      if (this.paused) {\r\n        return;\r\n      }\r\n      if (this.jobs.length == 0) {\r\n        this.paused = true\r\n        return;\r\n      }\r\n      const job = this.jobs.shift();\r\n      if (job != null) {\r\n        job().then(() => {\r\n          this.execute();\r\n        });\r\n      }\r\n    }\r\n    resume() {\r\n      if(!this.paused) {\r\n        return\r\n      }\r\n      this.paused = false;\r\n      setTimeout(() => {\r\n        this.execute();\r\n      }, 0)\r\n    }\r\n    reset() {\r\n      this.jobs = [];\r\n      this.paused = true;\r\n    }\r\n    get done() : boolean {\r\n      return this.jobs.length == 0;\r\n    }\r\n  }\r\n\r\n  function delay(time : number) : Promise<void> {\r\n    return new Promise(resolve => {\r\n      setTimeout(() => {\r\n        resolve()\r\n      }, time)\r\n    })\r\n  }\r\n\r\n  const bigList = ref<Item[]>([]);\r\n  const list = ref<Item[]>([]);\r\n  const jobs = ref<Jobs>(new Jobs());\r\n  const batchSize = ref<number>(100);\r\n  const scrolling = ref<boolean>(false);\r\n  const refresherTriggered = ref<boolean>(false);\r\n  const scrollendTimeout = ref<number>(-1);\r\n  const pulling = ref<boolean>(false);\r\n\r\n  function init(autoResumeJobs: boolean = true) {\r\n    // 将数据分批放入任务队列\r\n    const batchCount = Math.ceil(bigList.value.length / batchSize.value);\r\n    for (let i = 0; i < batchCount; i++) {\r\n      const start = i * batchSize.value;\r\n      const end = Math.min(start + batchSize.value, bigList.value.length);\r\n      jobs.value.add(async () => {\r\n        list.value.push(...bigList.value.slice(start, end));\r\n        // 两批数据之间增加延迟，防止卡顿时间太久\r\n        await nextTick();\r\n        await delay(100)\r\n      });\r\n    }\r\n    if(autoResumeJobs) {\r\n      jobs.value.resume();\r\n    }\r\n  }\r\n\r\n  const onScrollEnd = () => {\r\n    scrolling.value = false;\r\n    // 滚动结束，继续执行分批加载逻辑\r\n    jobs.value.resume();\r\n  };\r\n\r\n  const onScroll = () => {\r\n    // 部分平台不支持scrollend事件，使用定时器模拟\r\n    clearTimeout(scrollendTimeout.value)\r\n    scrollendTimeout.value = setTimeout(() => {\r\n      onScrollEnd()\r\n    }, 100)\r\n    if (scrolling.value) {\r\n      return;\r\n    }\r\n    scrolling.value = true;\r\n    // 滚动期间暂停分批加载，保证滚动流畅度\r\n    jobs.value.pause();\r\n  };\r\n\r\n  const onScrollToLower = () => {\r\n    // 分批加载进行中，暂不执行滚动到底部加载更多数据的逻辑\r\n    if (!jobs.value.done) {\r\n      return;\r\n    }\r\n    // 加载更多数据\r\n  };\r\n\r\n  const onRefresh = () => {\r\n    // 下拉刷新触发，重置任务队列\r\n    jobs.value.reset();\r\n    refresherTriggered.value = true\r\n    setTimeout(() => {\r\n      refresherTriggered.value = false;\r\n      list.value.splice(0, list.value.length);\r\n      /**\r\n       * refreshRestore事件会触发继续分批加载，此处init不自动调用resume。这样做能减少一些下拉刷新复位期间加载数据引发的卡顿。\r\n       * TODO 清空列表也会导致下拉刷新复位时发生卡顿，后续再优化\r\n       */\r\n      init(false);\r\n    }, 500)\r\n  };\r\n\r\n  const onRefresherPulling = () => {\r\n    if(pulling.value) {\r\n      return\r\n    }\r\n    pulling.value = true\r\n    // 在下拉刷新时暂停分批加载，避免影响刷新操作\r\n    jobs.value.pause()\r\n  };\r\n\r\n  const onRefresherRestore = () => {\r\n    pulling.value = false\r\n    // 下拉刷新结束后恢复分批加载\r\n    jobs.value.resume();\r\n  };\r\n\r\n  // 模拟大列表数据 - 相当于 created 生命周期\r\n  for (let i = 0; i < 2000; i++) {\r\n    bigList.value.push({\r\n      id: i,\r\n      name: `Wifi_` + i,\r\n      info: `信号强度: -${Math.floor(Math.random() * 60) + 40\r\n        } db, 安全性: WPA/WPA2/WPA3-Personal`,\r\n    } as Item);\r\n  }\r\n\r\n  onReady(() => {\r\n    init();\r\n  });\r\n</script>\r\n\r\n<style>\r\n  .tips {\r\n    margin: 10px;\r\n    border-radius: 5px;\r\n    padding: 10px;\r\n    background-color: white;\r\n  }\r\n\r\n  .item {\r\n    margin: 5px 10px;\r\n    padding: 10px;\r\n    border-radius: 5px;\r\n    background-color: white;\r\n  }\r\n</style>\r\n","import MiniProgramPage from 'W:/Workplace/2.小程序/lihai-app/pages/template/long-list-batch/long-list-batch.uvue'\nwx.createPage(MiniProgramPage)"],"names":["ref","__awaiter","nextTick","onReady","MiniProgramPage"],"mappings":"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"}